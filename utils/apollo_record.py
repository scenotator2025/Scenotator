from cyber_record.record import Record
from google.protobuf import json_format
import json


def build_scenario_dict_(record_root_dir, record_filename, map_name): 
    scenario_data_waymo = build_scenario_dict_from_apollo_recording(record_root_dir, record_filename, map_name)
    return scenario_data_waymo


def build_scenario_dict_from_apollo_recording(record_root_dir, record_filename, map_name): 
    if "/" != record_root_dir[-1]: 
        record_dir = record_root_dir + "/" + record_filename
    else: 
        record_dir = record_root_dir + record_filename
    
    messages = load_messages(record_dir)
    timestamps_seconds, all_tracks, timestamp_init, all_npcs = get_timestamps_obtacles_tracks(messages["perception"])
    ego_track = get_ego_track(messages["localization"], timestamp_init, timestamps_seconds, all_npcs)
    obstacle_tracks = all_tracks + ego_track
    map_data_raw = load_map_data_by_name(map_name)
    dynamic_map_states = get_dynamic_map_states(messages["signal"], timestamp_init, timestamps_seconds, map_data_raw["signals"], map_data_raw["signal_lane"])
    covered_lanes = get_covered_lanes(dynamic_map_states, map_data_raw["lanes"])
    map_features = get_map_features(map_data_raw, covered_lanes)
    
    scenario_dict = {
        "timestampsSeconds": get_final_timestamps(timestamps_seconds), 
        "tracks": obstacle_tracks, 
        "objectsOfInterest": [],  # Generated by models
        "scenarioId": f"{map_name}-{record_filename}",
        "sdcTrackIndex": len(all_tracks), 
        "dynamicMapStates": dynamic_map_states, 
        "mapFeatures": map_features, 
        "currentTimeIndex": 20, 
        "tracksToPredict": [],  # Generated by models
        "description": [],  # Generated by models
        "category": []  # Generated by models
    }

    return scenario_dict


def load_map_data_by_name(map_name): 
    map_json_dir = f"./utils/{map_name}.json"
    with open(map_json_dir, 'r') as fi: 
        map_data = json.load(fi)
    return map_data


"""
Functions for parsing Apollo recording files
"""


def pb2json(proto_msg):
    str = json_format.MessageToJson(proto_msg)
    json_msg = json.loads(str)
    return json_msg


def load_messages(record_dir):
    localization_msgs = []
    obstacle_msgs = []
    signal_msgs = []

    record = Record(record_dir)
    has_localization = False

    obstacle_msg_counter = 0
    for channel, message, _ in record.read_messages():

        if channel == "/apollo/localization/pose":
            frame = pb2json(message)
            localization_msgs.append(frame)
            has_localization = True

        elif channel == "/apollo/perception/obstacles":
            if has_localization and obstacle_msg_counter % 2 == 0: 
                frame = pb2json(message)
                obstacle_msgs.append(frame)
            obstacle_msg_counter += 1

        elif channel == "/apollo/perception/traffic_light":
            if has_localization: 
                frame = pb2json(message)
                signal_msgs.append(frame)
    
    messages = {
        "localization": localization_msgs, 
        "perception": obstacle_msgs, 
        "signal": signal_msgs
    }

    return messages


def get_final_timestamps(timestamps_seconds): 
    timestamps_seconds_final = []
    for timestamp in timestamps_seconds: 
        timestamps_seconds_final.append(timestamp-timestamps_seconds[0])
    return timestamps_seconds_final


def obstacle_type_parser(obj_type_apollo): 
    obj_type_mapping = {
        "UNKNOWN": "TYPE_UNSET", 
        "UNKNOWN_MOVABLE": "TYPE_OTHER", 
        "UNKNOWN_UNMOVABLE": "TYPE_OTHER", 
        "PEDESTRIAN": "TYPE_PEDESTRIAN", 
        "BICYCLE": "TYPE_CYCLIST", 
        "VEHICLE": "TYPE_VEHICLE"
    }
    return obj_type_mapping[obj_type_apollo]


def get_dummy_object_state(): 
    dummy_object_state = {
        "valid": False
    }
    return dummy_object_state


def get_object_state(object_detected): 
    obj_state = {
        "centerX": object_detected["position"]["x"],
        "centerY": object_detected["position"]["y"],
        # "centerZ": object_detected["position"]["z"],
        "centerZ": 0.0,
        "length": object_detected["length"],
        "width": object_detected["width"],
        "height": object_detected["height"],
        "heading": object_detected["theta"],
        "velocityX": object_detected["velocity"]["x"],
        "velocityY": object_detected["velocity"]["y"],
        "valid": True
    }
    flag = obj_state["velocityX"] > 0 and obj_state["velocityY"] > 0
    return obj_state, flag


def get_timestamps_obtacles_tracks(obstacle_msgs): 
    timestamps_seconds = []
    obstacle_tracks = {}

    timestamp_init = obstacle_msgs[0]["header"]["timestampSec"]
    flag_index_min = len(obstacle_msgs) - 100
    for frame in obstacle_msgs: 
        timestep = frame["header"]["timestampSec"] - timestamp_init
        timestamps_seconds.append(timestep)
        for obj_detected in frame["perceptionObstacle"]: 
            if obj_detected["id"] not in obstacle_tracks: 
                obj_info = {
                    "id": obj_detected["id"], 
                    "objectType": obstacle_type_parser(obj_detected["type"]), 
                    "states": [get_dummy_object_state() for _ in range(len(obstacle_msgs))]
                }
                obstacle_tracks[obj_detected["id"]] = obj_info
    
    for i in range(len(obstacle_msgs)): 
        for obj_detected in obstacle_msgs[i]["perceptionObstacle"]: 
            obj_id = obj_detected["id"]
            obstacle_tracks[obj_id]["states"][i], flag = get_object_state(obj_detected)
            if flag: 
                if i < flag_index_min: 
                    flag_index_min = i
    
    all_tracks = list(obstacle_tracks.values())
    all_npcs = list(obstacle_tracks.keys())

    # Clip sample
    timestamps_seconds = timestamps_seconds[flag_index_min: flag_index_min+100]
    for track in all_tracks: 
        track["states"] = track["states"][flag_index_min: flag_index_min+100]
    
    return timestamps_seconds, all_tracks, timestamp_init, all_npcs


def get_prev_next_idx(timestep_target, timesteps): 
    for i in range(1, len(timesteps)): 
        if timesteps[i-1] < timestep_target and timestep_target < timesteps[i]: 
            prev_idx, next_idx = i-1, i
            return prev_idx, next_idx
    return None, None


def calculate_position(pos_prev, vel_prev, t_prev, t_target): 
    t_delta = t_target - t_prev
    x = pos_prev[0] + vel_prev[0] * t_delta
    y = pos_prev[1] + vel_prev[1] * t_delta
    # z = pos_prev[2] + vel_prev[2] * t_delta
    return (x, y, 0.0)


def calculate_velocity(vel_prev, acce_prev, t_prev, t_target): 
    t_delta = t_target - t_prev
    v_x = vel_prev[0] + acce_prev[0] * t_delta
    v_y = vel_prev[1] + acce_prev[1] * t_delta
    return (v_x, v_y)


def calculate_heading(heading_prev, heading_next, t_prev, t_next, t_target): 
    heading = heading_prev + (heading_next-heading_prev) * (t_target - t_prev) / (t_next - t_prev)
    return heading


def get_ego_track(localization_msgs, timestamp_init, timestamps_seconds, all_npcs): 
    timesteps_loc = []
    positions = []  # x, y, z
    velocitys = []  # x, y, z
    accelerations = []  # x, y
    headings = []
    for frame in localization_msgs: 
        timestep = frame["header"]["timestampSec"] - timestamp_init
        timesteps_loc.append(timestep)
        pos = (frame["pose"]["position"]["x"], frame["pose"]["position"]["y"], frame["pose"]["position"]["z"]) if \
            frame["pose"]["position"]["x"] != 'NaN' and frame["pose"]["position"]["y"] != 'NaN' and frame["pose"]["position"]["z"] != 'NaN' else (0, 0, 0)
        positions.append(pos)
        vel = (frame["pose"]["linearVelocity"]["x"], frame["pose"]["linearVelocity"]["y"], frame["pose"]["linearVelocity"]["z"]) if \
            frame["pose"]["linearVelocity"]["x"] != 'NaN' and frame["pose"]["linearVelocity"]["y"] != 'NaN' and frame["pose"]["linearVelocity"]["z"] != 'NaN' else (0, 0, 0)
        velocitys.append(vel)
        acce = (frame["pose"]["linearAcceleration"]["x"], frame["pose"]["linearAcceleration"]["y"]) if \
            frame["pose"]["linearAcceleration"]["x"] != 'NaN' and frame["pose"]["linearAcceleration"]["y"] != 'NaN' else (0, 0)
        accelerations.append(acce)
        headings.append(frame["pose"]["heading"])
    
    states = []
    for timestamp in timestamps_seconds: 
        prev_idx, next_idx = get_prev_next_idx(timestamp, timesteps_loc)
        if prev_idx and next_idx: 
            pos_est = calculate_position(positions[prev_idx], velocitys[prev_idx], timesteps_loc[prev_idx], timestamp)
            vel_est = calculate_velocity(velocitys[prev_idx], accelerations[prev_idx], timesteps_loc[prev_idx], timestamp)
            heading_est = calculate_heading(headings[prev_idx], headings[next_idx], timesteps_loc[prev_idx], timesteps_loc[next_idx], timestamp)
            state = {
                "centerX": pos_est[0],
                "centerY": pos_est[1],
                "centerZ": pos_est[2],
                "length": 4.70,
                "width": 2.06,
                "height": 2.05,
                "heading": heading_est,
                "velocityX": vel_est[0], 
                "velocityY": vel_est[1], 
                "valid": True
            }
            states.append(state)
    
    ego_id = max(all_npcs) + 1
    ego_track = {
        "id": ego_id, 
        "objectType": "TYPE_VEHICLE", 
        "states": states
    }
    
    return [ego_track]


def lane_signal_state_paser(sig_type, sig_color): 
    color_mapping = {
        "UNKNOWN": "UNKNOWN", 
        "RED": "STOP", 
        "YELLOW": "CAUTION", 
        "GREEN": "GO", 
        "BLACK": "UNKNOWN"
    }
    state = sig_type + color_mapping[sig_color]
    return state


def calculate_frame_signal_state(frame_signal_state, signals_info, signal2lane): 
    frame_lane_states = []
    for sig_state in frame_signal_state: 
        sig_id, sig_color = sig_state[0], sig_state[1]
        sig_type = signals_info[sig_id]
        controlled_lanes = signal2lane[sig_id]
        lane_signal_type = lane_signal_state_paser(sig_type, sig_color)
        for c_lane in controlled_lanes: 
            frame_lane_states.append({
                "lane": c_lane[5:], 
                "state": lane_signal_type
            })
    return frame_lane_states


def get_dynamic_map_states(signal_msgs, timestamp_init, timestamps_seconds, signals_info, signal2lane): 
    timesteps_sig = []
    signal_states = []  # id, color
    for frame in signal_msgs: 
        timestep = frame["header"]["timestampSec"] - timestamp_init
        timesteps_sig.append(timestep)
        sig_state = []
        for signal in frame["trafficLight"]: 
            sig_state.append((signal["id"], signal["color"]))
        signal_states.append(sig_state)
    
    states = []
    for timestamp in timestamps_seconds: 
        prev_idx, next_idx = get_prev_next_idx(timestamp, timesteps_sig)
        if prev_idx and next_idx: 
            if (timestamp-timesteps_sig[prev_idx]) <= (timesteps_sig[next_idx]-timestep): 
                frame_state = calculate_frame_signal_state(signal_states[prev_idx], signals_info, signal2lane)
            else: 
                frame_state = calculate_frame_signal_state(signal_states[next_idx], signals_info, signal2lane)
            states.append({"laneStates": frame_state})
        else: 
            states.append({"laneStates": []})
    return states


def get_covered_lanes(dynamic_map_states, all_lanes): 
    covered_lanes = set()
    for frame in dynamic_map_states: 
        for lane_state in frame["laneStates"]: 
            covered_lanes.add("lane_"+lane_state["lane"])
    for lane in covered_lanes: 
        if "leftNeighbors" in all_lanes[lane]: 
            for n_lane in all_lanes[lane]["leftNeighbors"]: 
                covered_lanes.add("lane_"+n_lane["featureId"])
        if "rightNeighbors" in all_lanes[lane]: 
            for n_lane in all_lanes[lane]["rightNeighbors"]: 
                covered_lanes.add("lane_"+n_lane["featureId"])
    return covered_lanes


def get_covered_elements(covered_lanes, lane_mapping): 
    covered_elems = set()
    for c_lane in covered_lanes: 
        if c_lane in lane_mapping: 
            for c_map in lane_mapping[c_lane]: 
                covered_elems.add(c_map)
    return covered_elems


def get_map_features(map_data_raw, covered_lanes): 
    covered_roadlines = get_covered_elements(covered_lanes, map_data_raw["lane_roadline"])
    covered_crosswalks = get_covered_elements(covered_lanes, map_data_raw["lane_crosswalk"])
    covered_stopsigns = get_covered_elements(covered_lanes, map_data_raw["lane_stopsign"])
    lanes_info, roadlines_info, stopsigns_info, crosswalks_info = [], [], [], []
    for c_lane in covered_lanes: 
        lanes_info.append(map_data_raw["lanes"][c_lane])
    for c_rdln in covered_roadlines: 
        roadlines_info.append(map_data_raw["roadlines"][c_rdln])
    for c_stpsgn in covered_stopsigns: 
        stopsigns_info.append(map_data_raw["stopsigns"][c_stpsgn])
    for c_crswlk in covered_crosswalks: 
        crosswalks_info.append(map_data_raw["crosswalks"][c_crswlk])
    map_data = lanes_info + roadlines_info + stopsigns_info + crosswalks_info
    # print(len(lanes_info), len(roadlines_info), len(stopsigns_info), len(crosswalks_info))
    return map_data


"""
Functions for parsing Apollo map files
"""


def prepare_map_data(map_name, map_root_dir, save_dir): 
    if "/" != map_root_dir[-1]: 
        map_dir = map_root_dir + "/map_" + map_name + ".json"
    else: 
        map_dir = map_root_dir + "map_" + map_name + ".json"
    
    with open(map_dir, 'r') as fi: 
        apollo_map = json.load(fi)
    
    map_feature_data = extract_map_elements(apollo_map)

    map_feature_data_dir = f"{save_dir}/{map_name}.json"
    print("==========")
    print(f"Saving map data: {map_feature_data_dir} ...")
    with open(map_feature_data_dir,"w") as fo:
        fo.write(json.dumps(map_feature_data, indent=2))
    print("==========")


def extract_map_elements(apollo_map): 
    map_feature_data = {}
    all_lanes, all_roadlines, lane2roadlines, id_counter = extract_lanes_roadlines(apollo_map["laneList"])
    all_stopsigns, id_counter, lane2stopsigns = extract_stopsigns(apollo_map["stopSignList"], id_counter)
    all_crosswalks, _, lane2crosswalks = extract_crosswalks(apollo_map["crosswalkList"], id_counter)
    all_signals, signal2lane = extract_signals(apollo_map["signalList"])
    # map_feature_data = all_lanes + all_stopsigns + all_crosswalks
    map_feature_data["lanes"] = all_lanes
    map_feature_data["roadlines"] = all_roadlines
    map_feature_data["stopsigns"] = all_stopsigns
    map_feature_data["crosswalks"] = all_crosswalks
    map_feature_data["signals"] = all_signals
    map_feature_data["signal_lane"] = signal2lane
    map_feature_data["lane_roadline"] = lane2roadlines
    map_feature_data["lane_crosswalk"] = lane2crosswalks
    map_feature_data["lane_stopsign"] = lane2stopsigns
    return map_feature_data


def lane_type_parser(lane_type_apollo): 
    lane_type_mapping = {
        1: "TYPE_UNDEFINED",  # NONE
        2: "TYPE_SURFACE_STREET",  # CITY_DRIVING
        3: "TYPE_BIKE_LANE",  # BIKING
    }
    return lane_type_mapping[lane_type_apollo]


def get_lane_center_polyline(central_curve): 
    center_polyline = []
    for segment in central_curve["segmentList"]: 
        for point in segment["lineSegment"]["pointList"]: 
            center_polyline.append(point)
    return center_polyline


def get_roadlines_of_single_lane(left_bound, id_counter):
    roadlines = {}
    boundaries = []
    boundaries_id = []
    for segment in left_bound["curve"]["segmentList"]: 
        polyline = []
        for point in segment["lineSegment"]["pointList"]: 
            polyline.append(point)
        roadline = {
            "id": str(id_counter), 
            "roadLine": {"polyline": polyline}
        }
        roadlines[str(id_counter)] = roadline
        boundary = {"boundaryFeatureId": str(id_counter)}
        boundaries.append(boundary)
        boundaries_id.append(str(id_counter))
        id_counter += 1
    return roadlines, boundaries, boundaries_id, id_counter


def get_entry_lanes(predecessor_list): 
    entry_lanes = []
    for item in predecessor_list: 
        entry_lanes.append(item["id"][5:])
    return entry_lanes


def get_exit_lanes(successor_list): 
    exit_lanes = []
    for item in successor_list: 
        exit_lanes.append(item["id"][5:])
    return exit_lanes


def get_left_neighbor_lanes(left_forward_list): 
    left_neighbors = []
    for item in left_forward_list: 
        left_neighbors.append({
            "featureId": item["id"][5:]
        })
    return left_neighbors


def get_right_neighbor_lanes(right_forward_list): 
    right_neighbors = []
    for item in right_forward_list: 
        right_neighbors.append({
            "featureId": item["id"][5:]
        })
    return right_neighbors


def extract_lanes_roadlines(lane_list): 
    all_lanes = {}
    all_roadlines = {}
    lane2roadlines = {}
    id_counter = len(lane_list)
    for lane in lane_list: 
        lane_id = lane["id"]["id"][5:]
        lane_type = lane["type"] if "type" in lane else 0
        speed_mps = lane["speedLimit"] if "speedLimit" in lane else 20
        left_roadlines, left_boundaries, left_ids, id_counter = get_roadlines_of_single_lane(lane["leftBoundary"], id_counter)
        right_roadlines, right_boundaries, right_ids, id_counter = get_roadlines_of_single_lane(lane["rightBoundary"], id_counter)
        lane_info = {
            "speedLimitMph": speed_mps * 2.23693629, 
            "type": lane_type_parser(lane_type), 
            "interpolating": False, 
            "polyline": get_lane_center_polyline(lane["centralCurve"]), 
            "entryLanes": get_entry_lanes(lane["predecessorIdList"]), 
            "exitLanes": get_exit_lanes(lane["successorIdList"]), 
            "leftNeighbors": get_left_neighbor_lanes(lane["leftNeighborForwardLaneIdList"]), 
            "rightNeighbors": get_right_neighbor_lanes(lane["rightNeighborForwardLaneIdList"]), 
            "leftBoundaries": left_boundaries, 
            "rightBoundaries": right_boundaries
        }
        all_lanes[lane["id"]["id"]] = {
            "id": lane_id, 
            "lane": lane_info
        }
        all_roadlines.update(left_roadlines)
        all_roadlines.update(right_roadlines)
        lane2roadlines[lane["id"]["id"]] = left_ids + right_ids
    return all_lanes, all_roadlines, lane2roadlines, id_counter


def get_lanes_controlled_by_stopsign(stopsign): 
    controlled_lanes = []
    stopsign_id = stopsign["id"]["id"]
    for id_overlap in stopsign["overlapIdList"]: 
        id_ovl = id_overlap["id"].replace("overlap_", "")
        id_ovl = id_ovl.replace(f"{stopsign_id}_", "")
        if "lane_" in id_ovl: 
            id_ovl = id_ovl.replace("lane_", "")
            controlled_lanes.append(id_ovl)
    return controlled_lanes


def extract_stopsigns(stopsign_list, id_counter): 
    all_stopsigns = {}
    lane2stopsigns = {}
    for stopsign in stopsign_list: 
        stopsign_id = str(id_counter)
        controlled_lanes = get_lanes_controlled_by_stopsign(stopsign)
        stopsign_info = {
            "lane": controlled_lanes
        }
        all_stopsigns[stopsign["id"]["id"]] = {
            "id": stopsign_id, 
            "stopSign": stopsign_info
        }
        id_counter += 1
        for c_lane in controlled_lanes: 
            c_lane_key = "lane_" + c_lane
            if c_lane_key not in lane2stopsigns: 
                lane2stopsigns[c_lane_key] = [stopsign["id"]["id"]]
            else: 
                lane2stopsigns[c_lane_key].append(stopsign["id"]["id"])
    return all_stopsigns, id_counter, lane2stopsigns


def get_lanes_covered_by_crosswalk(crosswalk): 
    covered_lanes = []
    crosswalk_id = crosswalk["id"]["id"]
    for id_overlap in crosswalk["overlapIdList"]: 
        id_ovl = id_overlap["id"].replace("overlap_", "")
        id_ovl = id_ovl.replace(f"{crosswalk_id}_", "")
        if "lane_" in id_ovl: 
            # id_ovl = id_ovl.replace("lane_", "")
            covered_lanes.append(id_ovl)
    return covered_lanes


def extract_crosswalks(crosswalk_list, id_counter): 
    all_crosswalks = {}
    lane2crosswalk = {}
    for crosswalk in crosswalk_list: 
        crosswalk_id = str(id_counter)
        crosswalk_info = {
            "polygon": crosswalk["polygon"]["pointList"]
        }
        all_crosswalks[crosswalk["id"]["id"]] = {
            "id": crosswalk_id, 
            "crosswalk": crosswalk_info
        }
        id_counter += 1
        covered_lanes = get_lanes_covered_by_crosswalk(crosswalk)
        for c_lane in covered_lanes: 
            if c_lane not in lane2crosswalk: 
                lane2crosswalk[c_lane] = [crosswalk["id"]["id"]]
            else: 
                lane2crosswalk[c_lane].append(crosswalk["id"]["id"])
    return all_crosswalks, id_counter, lane2crosswalk


def get_lanes_controlled_by_signal(signal): 
    controlled_lanes = []
    signal_id = signal["id"]["id"]
    for id_overlap in signal["overlapIdList"]: 
        id_ovl = id_overlap["id"].replace("overlap_", "")
        id_ovl = id_ovl.replace(f"{signal_id}_", "")
        if "lane_" in id_ovl: 
            controlled_lanes.append(id_ovl)
    return controlled_lanes


def extract_signals(signal_list): 
    all_signals = {}
    signal2lane = {}
    for signal in signal_list: 
        signal_id = signal["id"]["id"]
        signal_type = "LANE_STATE_"
        all_signals[signal_id] = signal_type
        controlled_lanes = get_lanes_controlled_by_signal(signal)
        signal2lane[signal_id] = controlled_lanes
    return all_signals, signal2lane
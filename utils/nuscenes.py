from nuscenes.nuscenes import NuScenes
from nuscenes.map_expansion.map_api import NuScenesMap
from shapely.geometry import Point, MultiPoint, Polygon
from shapely.strtree import STRtree
from collections import defaultdict
from pyquaternion import Quaternion
from math import sqrt
import numpy as np
import json
from multiprocessing import Pool


def build_scenario_dict_(data_dir, save_root_dir, mode='test'):
    nusc = NuScenes(version='v1.0-trainval', dataroot=data_dir)  # TODO
    if mode == 'test':
        for scenario in nusc.scene:
            scenario_data = build_scenario_dict_from_nuscenes(scenario, nusc)
            TEST_DIR = save_root_dir + scenario_data["scenarioId"][:10] + ".json"
            with open(TEST_DIR, 'w') as f:
                json.dump(scenario_data, f, indent=2)
    elif mode == 'mult':
        with Pool(processes=3) as pool:
            results = [pool.apply_async(process_single_scenario, args=(scenario, save_root_dir, nusc, ))
                       for scenario in nusc.scene]
            final_results = [result.get() for result in results]
    return


def process_single_scenario(scenario, save_root_dir, nusc):
    scenario_data = build_scenario_dict_from_nuscenes(scenario, nusc)
    TEST_DIR = save_root_dir + scenario_data["scenarioId"][:10] + ".json"
    with open(TEST_DIR, 'w') as f:
        json.dump(scenario_data, f, indent=2)
    return True


"""
Functions for parsing nuScenes dataset samples
"""


def build_scenario_dict_from_nuscenes(scenario, nusc): 
    ego_track_id = 0
    scenario_id, map_name, data_extracted = extracting_metadata(scenario, nusc, ego_track_id)
    map_data_raw = load_map_data_by_name(map_name)

    ts_secs = get_timestamps_sec(data_extracted[ego_track_id])
    tracks, ego_idx = get_all_tracks(ts_secs, data_extracted, ego_track_id)
    
    scenario_dict = {
        "timestampsSeconds": ts_secs, 
        "tracks": tracks, 
        "objectsOfInterest": [],  # Generated by models
        "scenarioId": scenario_id, 
        "sdcTrackIndex": ego_idx, 
        "dynamicMapStates": [{"laneStates": []} for _ in range(len(ts_secs))],  # Do not support this field
        "mapFeatures": get_map_features(map_data_raw, tracks),  
        "currentTimeIndex": 4, 
        "tracksToPredict": [],  # Generated by models
    }

    return scenario_dict


def get_timestamps_sec(scenario_sample_ego): 
    timestamps_secs = []
    for frame in scenario_sample_ego: 
        timestamps_secs.append(frame["timestamp"])
    return timestamps_secs


"""
Functions for extracting obstacle tracks INFO. 
"""


def get_dummy_state(): 
    dummy_object_state = {
        "valid": False
    }
    return dummy_object_state


def object_type_paser(obj_type_nus): 
    if "animal" in obj_type_nus: 
        return "TYPE_OTHER"
    elif "human" in obj_type_nus: 
        return "TYPE_PEDESTRIAN"
    elif "cycle" in obj_type_nus: 
        return "TYPE_CYCLIST"
    elif "vehicle" in obj_type_nus: 
        return "TYPE_VEHICLE"
    else: 
        return "TYPE_UNSET"


def get_all_tracks(ts_secs, track_extracted, ego_track_id): 
    # all_obstacles.remove("scenarioId")
    tracks = []
    for obj_id in track_extracted: 
        if not track_extracted[obj_id]: 
            continue
        obj_type = track_extracted[obj_id][0]["objectType"]
        if "object" in obj_type: 
            continue 
        track = {
            "id": obj_id, 
            "objectType": object_type_paser(obj_type)
        }
        states = [get_dummy_state() for _ in range(len(ts_secs))]
        for frame in track_extracted[obj_id]: 
            index = ts_secs.index(frame["timestamp"])
            states[index]["valid"] = True
            states[index]["centerX"] = frame["centerX"]
            states[index]["centerY"] = frame["centerY"]
            states[index]["centerZ"] = frame["centerZ"]
            states[index]["heading"] = frame["heading"]
            states[index]["velocityX"] = frame["velocityX"]
            states[index]["velocityX"] = frame["velocityX"]
            states[index]["length"] = frame["length"]
            states[index]["width"] = frame["width"]
            states[index]["height"] = frame["height"]
        track["states"] = states
        tracks.append(track)
    ego_idx = -1
    for i in range(len(tracks)): 
        if tracks[i]["id"] == ego_track_id: 
            ego_idx = i
            break
    return tracks, ego_idx


def extracting_metadata(scenario, nusc, ego_track_id): 
    tracks = defaultdict(list)

    # Get scenario ID
    frame_token = scenario['first_sample_token']
    scenario_id = f"{scenario['name']}: {scenario['description']}"
    # Get scenario map name
    log = nusc.get('log', scenario['log_token'])
    map_name = log['location'] 
    # Get the first timestamp
    first_frame = nusc.get('sample', frame_token)
    first_timestamp = first_frame['timestamp']

    while frame_token:
        frame = nusc.get('sample', frame_token)
        # frame: ['token', 'timestamp', 'prev', 'next', 'scene_token', 'data', 'anns']
        timestamp = frame['timestamp']
        timestamp_sec = round((timestamp - first_timestamp) / 1e6, 1)

        # Get ego pose
        lidar_token = frame['data']['LIDAR_TOP']
        sd = nusc.get('sample_data', lidar_token)
        ego_pose = nusc.get('ego_pose', sd['ego_pose_token'])
        pos = ego_pose['translation']   # x, y, z
        rot = ego_pose['rotation']      # quaternion

        # Need to estimate the ego's velocity vector
        tracks[ego_track_id].append({
            'timestamp': timestamp_sec,
            'objectType': 'vehicle.car',
            'centerX': pos[0],
            'centerY': pos[1],
            'centerZ': pos[2],
            'valid': True, 
            'heading': quaternion_to_yaw(rot), 
            'velocityX': 0.0,  # Need to estimate
            'velocityY': 0.0,  # Need to estimate
            'length': 4.084, 
            'width': 1.73, 
            'height': 1.562, 
        })

        # Get object info from annotations
        obj_id_counter = 0
        for ann_token in frame['anns']: 
            obj_id_counter += 1
            ann = nusc.get('sample_annotation', ann_token)
            # Get object id
            # track_id = ann['instance_token']
            track_id = obj_id_counter
            category = ann['category_name']
            pos = ann['translation']  # x, y, z
            size = ann['size']        # width, length, height
            rot = ann['rotation']     # quaternion
            velocity = nusc.box_velocity(ann['token'])  # optional
            velocity = velocity.tolist()[:2] if velocity is not None else [0.0, 0.0]

            tracks[track_id].append({
                'timestamp': timestamp_sec,
                'objectType': category,
                'centerX': pos[0],
                'centerY': pos[1],
                'centerZ': pos[2],
                'valid': True, 
                'heading': quaternion_to_yaw(rot),
                'velocityX': velocity[0], 
                'velocityY': velocity[1], 
                'length': size[1], 
                'width': size[0], 
                'height': size[2], 
            })

        frame_token = frame['next']
    
    # Estimate ego's velocity vectors
    for i in range(1, len(tracks[ego_track_id])): 
        dt = tracks[ego_track_id][i]["timestamp"] - tracks[ego_track_id][i-1]["timestamp"]
        dx = tracks[ego_track_id][i]["centerX"] - tracks[ego_track_id][i-1]["centerX"]
        dy = tracks[ego_track_id][i]["centerY"] - tracks[ego_track_id][i-1]["centerY"]
        tracks[ego_track_id][i-1]["velocityX"] = dx / dt
        tracks[ego_track_id][i-1]["velocityY"] = dy / dt
    tracks[ego_track_id][-1]["velocityX"] = tracks[ego_track_id][-2]["velocityX"]
    tracks[ego_track_id][-1]["velocityY"] = tracks[ego_track_id][-2]["velocityY"]

    return scenario_id, map_name, tracks


def quaternion_to_yaw(quat):
    q = Quaternion(quat)  # w, x, y, z
    yaw = q.yaw_pitch_roll[0]  # return (yaw, pitch, roll)
    return yaw  # [-pi, pi]


"""
Functions for extracting map INFO. 
"""

# Save and Load map feature data. 


def load_map_data_by_name(map_name): 
    map_json_dir = f"./utils/{map_name}.json"
    with open(map_json_dir, 'r') as fi: 
        map_data = json.load(fi)
    return map_data


def get_map_features(map_data_raw, tracks): 
    roadlines, lanes, crosswalks = [], [], []
    trajectory_area = get_area_of_all_covered_points(tracks)
    all_polygons, polygons_index = get_polygon_of_all_map_elements(map_data_raw)
    all_cover_id = get_candidate_map_elements(trajectory_area, all_polygons, polygons_index)
    for c_id in all_cover_id: 
        # if c_id in map_data_raw["roadlines"]: 
        #     roadlines.append(map_data_raw["roadlines"][c_id])
        if c_id in map_data_raw["lanes"]: 
            lanes.append(map_data_raw["lanes"][c_id])
        if c_id in map_data_raw["crosswalks"]: 
            crosswalks.append(map_data_raw["crosswalks"][c_id])
    roadlines = get_covered_roadlines(lanes, map_data_raw["roadlines"])
    map_features = roadlines + lanes + crosswalks
    return map_features


def prepare_map_data(map_expansion_dir, save_dir): 
    all_maps = ["boston-seaport", "singapore-onenorth", "singapore-queenstown", "singapore-hollandvillage"]
    for map_name in all_maps: 
        print(f"==========\nNow: {map_name} of {map_expansion_dir} ...")
        nusc_map = NuScenesMap(dataroot=map_expansion_dir, map_name=map_name)
        all_lane_tokens, basic_info_extracted, polygons_extracted, entry_exit_extracted, all_boundaries_extracted, \
            lane2boundaries_extracted, neighbor_lanes_extracted, crosswalks_extracted = extract_map_features(nusc_map)
        map_feature_data = assemble_map_features(all_lane_tokens, basic_info_extracted, polygons_extracted, entry_exit_extracted, 
                                                 all_boundaries_extracted, lane2boundaries_extracted, neighbor_lanes_extracted, 
                                                 crosswalks_extracted)
        map_feature_data_dir = f"{save_dir}/{map_name}.json"
        print(f"Saving map data: {map_feature_data_dir} ...")
        with open(map_feature_data_dir,"w") as fo:
            fo.write(json.dumps(map_feature_data, indent=2))
        print("==========")


# Extract RoadLine INFO. 


def get_roadline_polyline(point_start, point_end): 
    pt_start = {"x": point_start["x"], "y": point_start["y"], "z": 0.001}
    pt_end = {"x": point_end["x"], "y": point_end["y"], "z": 0.001}
    polyline = [pt_start, pt_end]
    return polyline


def get_all_boundaries(all_lane_tokens, nusc_map): 
    lane2boundaries = {}
    all_boundaries = {}
    for lane_token in all_lane_tokens: 
        lane_curr = nusc_map.get("lane", lane_token)
        left_boundaries = []
        for i in range(1, len(lane_curr["left_lane_divider_segments"])): 
            boundary_token = lane_curr["left_lane_divider_segments"][i-1]["node_token"]
            boundary_type = boundary_type_parser(lane_curr["left_lane_divider_segments"][i-1]["segment_type"])
            pt_end_tkn = lane_curr["left_lane_divider_segments"][i]["node_token"]
            pt_start = nusc_map.get("node", boundary_token)
            pt_end = nusc_map.get("node", pt_end_tkn)
            boundary_polyline = get_roadline_polyline(pt_start, pt_end)
            all_boundaries[boundary_token] = {
                "type": boundary_type, 
                "polyline": boundary_polyline
            }
            left_boundary = {
                "token": boundary_token, 
                "type": boundary_type
            }
            left_boundaries.append(left_boundary)
        right_boundaries = []
        for i in range(1, len(lane_curr["right_lane_divider_segments"])): 
            boundary_token = lane_curr["right_lane_divider_segments"][i-1]["node_token"]
            boundary_type = boundary_type_parser(lane_curr["right_lane_divider_segments"][i-1]["segment_type"])
            pt_end_tkn = lane_curr["right_lane_divider_segments"][i]["node_token"]
            pt_start = nusc_map.get("node", boundary_token)
            pt_end = nusc_map.get("node", pt_end_tkn)
            boundary_polyline = get_roadline_polyline(pt_start, pt_end)
            all_boundaries[boundary_token] = {
                "type": boundary_type, 
                "polyline": boundary_polyline
            }
            right_boundary = {
                "token": boundary_token, 
                "type": boundary_type
            }
            right_boundaries.append(right_boundary)
        lane2boundaries[lane_token] = {"left": left_boundaries, "right": right_boundaries}
    return all_boundaries, lane2boundaries


# Extract LaneCenter/Lane INFO.


def get_roadtype_polygon(polygon_token, nusc_map): 
    polygon_curr = nusc_map.extract_polygon(polygon_token)
    points = polygon_curr.exterior.coords
    polygon_points = []
    for pt in points: 
        pt_dict = {
            "x": pt[0], 
            "y": pt[1], 
            "z": 0.001
        }
        polygon_points.append(pt_dict)
    return polygon_points


def lanetype_spdlimit_parser(lane_type_ns): 
    lane_type_mapping = {
        "CAR": "TYPE_SURFACE_STREET", 
    }
    speed_limit_mapping = {
        "CAR": 40.0, 
    }
    return lane_type_mapping[lane_type_ns], speed_limit_mapping[lane_type_ns]


def get_basic_lane_info(all_lane_tokens, nusc_map): 
    all_basic_info = {}
    for lane_token in all_lane_tokens: 
        lane_curr = nusc_map.get("lane", lane_token)
        lane_type, spdlimit = lanetype_spdlimit_parser(lane_curr["lane_type"])
        basic_info_curr = {
            "type": lane_type, 
            "speedLimitMph": spdlimit, 
            "interpolating": False
        }
        all_basic_info[lane_token] = basic_info_curr
    return all_basic_info


def get_all_lane_polygons(all_lane_tokens, nusc_map): 
    all_lane_polygons = {}
    for lane_token in all_lane_tokens: 
        lane_curr = nusc_map.get("lane", lane_token)
        polygon_curr = get_roadtype_polygon(lane_curr["polygon_token"], nusc_map)
        all_lane_polygons[lane_token] = polygon_curr
    return all_lane_polygons


def get_all_lane_connectors(nusc_map): 
    all_connector_tokens = []
    for connector in nusc_map.lane_connector: 
        all_connector_tokens.append(connector["token"])
    return all_connector_tokens


def get_dummy_mapping_con2lane(all_connector_tokens): 
    mp_c2l = {}
    for token in all_connector_tokens: 
        mp_c2l[token] = {"entry": [], "exit": []}
    return mp_c2l


def get_single_mapping_lane2con(lane_token, nusc_map): 
    lanes_connected = {
        "incoming": nusc_map.get_incoming_lane_ids(lane_token), 
        "outgoing": nusc_map.get_outgoing_lane_ids(lane_token)
    }
    return lanes_connected


def get_mapping_con2lane(all_lane_tokens, nusc_map):
    all_connector_tokens = get_all_lane_connectors(nusc_map)
    mp_c2l = get_dummy_mapping_con2lane(all_connector_tokens)
    for lane_token in all_lane_tokens: 
        single_mp_l2c = get_single_mapping_lane2con(lane_token, nusc_map)
        for c_token in single_mp_l2c["incoming"]: 
            if c_token in mp_c2l: 
                mp_c2l[c_token]["exit"].append(lane_token)
        for c_token in single_mp_l2c["outgoing"]: 
            if c_token in mp_c2l: 
                mp_c2l[c_token]["entry"].append(lane_token)
    return mp_c2l


def get_all_lanes_entry_exit(all_lane_tokens, nusc_map): 
    mapping_c2l = get_mapping_con2lane(all_lane_tokens, nusc_map)
    mapping_l2l = {}
    for lane_token in all_lane_tokens: 
        single_mp_l2c = get_single_mapping_lane2con(lane_token, nusc_map)
        entry_lane_tokens, exit_lane_tokens = [], []
        for c_token in single_mp_l2c["incoming"]: 
            if c_token in mapping_c2l and mapping_c2l[c_token]["exit"][0] == lane_token and mapping_c2l[c_token]["entry"]: 
                entry_lane_tokens.append(mapping_c2l[c_token]["entry"][0])
        for c_token in single_mp_l2c["outgoing"]: 
            if c_token in mapping_c2l and mapping_c2l[c_token]["entry"][0] == lane_token and mapping_c2l[c_token]["exit"]: 
                exit_lane_tokens.append(mapping_c2l[c_token]["exit"][0])
        mapping_l2l[lane_token] = {"entry": entry_lane_tokens, "exit": exit_lane_tokens}
    return mapping_l2l


def get_lane_direction_vec(lane, nusc_map): 
    start_line = nusc_map.extract_line(lane["from_edge_line_token"])
    end_line = nusc_map.extract_line(lane["to_edge_line_token"])
    direction_vec = (end_line.centroid.x - start_line.centroid.x, end_line.centroid.y - start_line.centroid.y)
    return direction_vec


def boundary_type_parser(boundary_type_ns): 
    lane_mark_mapping = {
        "NIL": "TYPE_UNKNOWN", 
        "SINGLE_ZIGZAG_WHITE": "TYPE_UNKNOWN", 
        "DOUBLE_DASHED_WHITE": "TYPE_BROKEN_SINGLE_WHITE", 
        "SINGLE_SOLID_WHITE": "TYPE_SOLID_SINGLE_WHITE", 
        "DOUBLE_SOLID_WHITE": "TYPE_SOLID_DOUBLE_WHITE", 
        "SINGLE_SOLID_YELLOW": "TYPE_SOLID_SINGLE_YELLOW", 
    }
    return lane_mark_mapping[boundary_type_ns]


def get_left_right_normals(vector):
    vector = np.array(vector, dtype=np.float64)
    norm = np.linalg.norm(vector)
    unit_vector = vector / norm
    # left normal: (-y, x)
    left_normal = np.array([-unit_vector[1], unit_vector[0]]).tolist()
    # right normal: (y, -x)
    right_normal = np.array([unit_vector[1], -unit_vector[0]]).tolist()
    return left_normal, right_normal


def get_sample_point(point_ori, normal, radius=3.5): 
    x = normal[0]*radius + point_ori[0]
    y = normal[1]*radius + point_ori[1]
    return (x, y)


def is_the_same_direction(vec_1, vec_2): 
    len_vec_1 = sqrt(vec_1[0]**2 + vec_1[1]**2)
    len_vec_2 = sqrt(vec_2[0]**2 + vec_2[1]**2)
    cos_theta = (vec_1[0]*vec_2[0] + vec_1[1]*vec_2[1]) / (len_vec_1 * len_vec_2)
    if cos_theta > 0: 
        return True
    else: 
        return False


def is_neighbor_lane_going_same_direction(neighbor_lane_token, d_vec_curr, nusc_map): 
    nusc_map
    neighbor_lane = nusc_map.get("lane", neighbor_lane_token)
    d_vec_n = get_lane_direction_vec(neighbor_lane, nusc_map)
    return is_the_same_direction(d_vec_curr, d_vec_n)


def get_neighbor_lanes(all_lane_tokens, nusc_map): 
    all_neighbor_lanes = {}
    for lane_token in all_lane_tokens: 
        lane_curr = nusc_map.get("lane", lane_token)
        left_neighbor, right_neighbor = "", ""
        d_vec_curr = get_lane_direction_vec(lane_curr, nusc_map)
        lane_center_pt = nusc_map.extract_polygon(lane_curr["polygon_token"]).centroid.coords[0]
        left_normal, right_normal = get_left_right_normals(d_vec_curr)
        left_sample_point = get_sample_point(lane_center_pt, left_normal)
        right_sample_point = get_sample_point(lane_center_pt, right_normal)
        left_lane_token = nusc_map.get_closest_lane(left_sample_point[0], left_sample_point[1], radius=1)
        right_lane_token = nusc_map.get_closest_lane(right_sample_point[0], right_sample_point[1], radius=1)
        if "" != left_lane_token and left_lane_token in all_lane_tokens: 
            if is_neighbor_lane_going_same_direction(left_lane_token, d_vec_curr, nusc_map): 
                left_neighbor = left_lane_token
        if "" != right_lane_token and right_lane_token in all_lane_tokens: 
            if is_neighbor_lane_going_same_direction(right_lane_token, d_vec_curr, nusc_map): 
                right_neighbor = right_lane_token
        all_neighbor_lanes[lane_token] = {"leftNeighborToken": left_neighbor, "rightNeighborToken": right_neighbor}
    return all_neighbor_lanes


def get_all_lane_tokens(nusc_map): 
    all_lane_tokens = []
    for lane in nusc_map.lane: 
        all_lane_tokens.append(lane["token"])
    return all_lane_tokens


# Extract Crosswalk INFO. 

def get_all_crosswalks(nusc_map): 
    crswlks_extracted = []
    for crswlk in nusc_map.ped_crossing: 
        crswlk_token = crswlk["token"]
        polygon_token = crswlk["polygon_token"]
        polygon_pts = get_roadtype_polygon(polygon_token, nusc_map)
        crswlk_dict = {
            "token": crswlk_token, 
            "polygon": polygon_pts
        }
        crswlks_extracted.append(crswlk_dict)
    return crswlks_extracted


# Extract raw MapFeatures. 

def extract_map_features(nusc_map): 
    all_lane_tokens = get_all_lane_tokens(nusc_map)
    # Extract necessary data
    print("Start extracting ...")
    basic_info_extracted = get_basic_lane_info(all_lane_tokens, nusc_map)
    polygons_extracted = get_all_lane_polygons(all_lane_tokens, nusc_map)
    entry_exit_extracted = get_all_lanes_entry_exit(all_lane_tokens, nusc_map)
    all_boundaries_extracted, lane2boundaries_extracted = get_all_boundaries(all_lane_tokens, nusc_map)
    print("Finish extracting lane and boundary INFO ...")
    neighbor_lanes_extracted = get_neighbor_lanes(all_lane_tokens, nusc_map)
    crosswalks_extracted = get_all_crosswalks(nusc_map)
    print("Finish extracting crosswalk INFO ...")
    return all_lane_tokens, basic_info_extracted, polygons_extracted, entry_exit_extracted, all_boundaries_extracted, \
        lane2boundaries_extracted, neighbor_lanes_extracted, crosswalks_extracted


def assemble_map_features(all_lane_tokens, basic_info_extracted, polygons_extracted, entry_exit_extracted, 
                          all_boundaries_extracted, lane2boundaries_extracted, neighbor_lanes_extracted, crosswalks_extracted): 
    print("Start assembling ...")
    feature_data_counter = 1
    all_roadlines, mapping_tkn2id, feature_data_counter = prepara_data_roadlines(all_boundaries_extracted, feature_data_counter)
    print("Finish assembling roadline INFO ...")
    all_lanes, feature_data_counter = prepare_data_lanes(all_lane_tokens, mapping_tkn2id, basic_info_extracted, polygons_extracted, entry_exit_extracted, 
                                                         lane2boundaries_extracted, neighbor_lanes_extracted, feature_data_counter)
    print("Finish assembling lane INFO ...")
    all_crosswalks, feature_data_counter = prepara_data_crosswalks(crosswalks_extracted, feature_data_counter)
    print("Finish assembling crosswalk INFO ...")
    # map_features = all_roadlines + all_lanes + all_crosswalks
    map_features = {
        "roadlines": all_roadlines, 
        "lanes": all_lanes, 
        "crosswalks": all_crosswalks
    }
    return map_features


def prepara_data_roadlines(all_boundaries_extracted, feature_data_counter): 
    all_roadlines = {}
    mapping_tkn2id = {}
    for bnd_tkn in all_boundaries_extracted: 
        bnd = all_boundaries_extracted[bnd_tkn]
        bnd_id = feature_data_counter
        boundary = {
            "id": str(bnd_id), "roadLine": {"type": bnd["type"], "polyline": bnd["polyline"]}
        }
        all_roadlines[str(bnd_id)] = boundary
        mapping_tkn2id[bnd_tkn] = str(bnd_id)
        feature_data_counter += 1
    return all_roadlines, mapping_tkn2id, feature_data_counter


def prepare_data_lanes(all_lane_tokens, mapping_tkn2id_bnd, basic_info_extracted, polygons_extracted, entry_exit_extracted, 
                       lane2boundaries_extracted, neighbor_lanes_extracted, feature_data_counter): 
    all_lanes = {}
    mapping_tkn2id_ln = {}
    for l_tkn in all_lane_tokens: 
        mapping_tkn2id_ln[l_tkn] = str(feature_data_counter)
        feature_data_counter += 1
    for l_tkn in all_lane_tokens: 
        lane_info = {
            "type": basic_info_extracted[l_tkn]["type"], 
            "speedLimitMph": basic_info_extracted[l_tkn]["speedLimitMph"], 
            "interpolating": False, 
            "polyline": polygons_extracted[l_tkn], 
        }
        lane_info["entryLanes"] = token2id_mapping_batch(entry_exit_extracted[l_tkn]["entry"], mapping_tkn2id_ln)
        lane_info["exitLanes"] = token2id_mapping_batch(entry_exit_extracted[l_tkn]["exit"], mapping_tkn2id_ln)
        left_boundaries = get_boundaries_one_side(lane2boundaries_extracted[l_tkn]["left"], mapping_tkn2id_bnd)
        lane_info["leftBoundaries"] = left_boundaries 
        right_boundaries = get_boundaries_one_side(lane2boundaries_extracted[l_tkn]["right"], mapping_tkn2id_bnd)
        lane_info["rightBoundaries"] = right_boundaries
        lane_info["leftNeighbors"] = get_neighbors_one_side(neighbor_lanes_extracted[l_tkn]["leftNeighborToken"], left_boundaries, mapping_tkn2id_ln)
        lane_info["rightNeighbors"] = get_neighbors_one_side(neighbor_lanes_extracted[l_tkn]["rightNeighborToken"], left_boundaries, mapping_tkn2id_ln)
        feature_info = {
            "id": mapping_tkn2id_ln[l_tkn], 
            "lane": lane_info
        }
        all_lanes[feature_info["id"]] = feature_info
    return all_lanes, feature_data_counter


def get_boundaries_one_side(boundaries_one_side, mapping_tkn2id_bnd): 
    boundaries = []
    for bnd in boundaries_one_side: 
        l_bnd = {
            "boundaryFeatureId": token2id_mapping(bnd["token"], mapping_tkn2id_bnd), 
            "boundaryType": bnd["type"]
        }
        boundaries.append(l_bnd)
    return boundaries


def get_neighbors_one_side(neighbors_one_side, boundaries_one_side, mapping_tkn2id_ln): 
    neighbor = {}
    if neighbors_one_side != "": 
        neighbor["featureId"] = token2id_mapping(neighbors_one_side, mapping_tkn2id_ln)
        neighbor["boundaries"] = boundaries_one_side
    return [neighbor]


def token2id_mapping_batch(token_batch, mapping): 
    id_batch = []
    for token in token_batch:
        id_batch.append(mapping[token])
    return id_batch


def token2id_mapping(token, mapping): 
    return mapping[token]


def prepara_data_crosswalks(crosswalks_extracted, feature_data_counter):
    all_crosswalks = {}
    for crswlk in crosswalks_extracted: 
        crswlk_info = {
            "id": str(feature_data_counter), 
            "crosswalk": {
                "polygon": crswlk["polygon"]
            }
        }
        all_crosswalks[str(feature_data_counter)] = crswlk_info
        feature_data_counter += 1
    return all_crosswalks, feature_data_counter


# Extract MapFeatures. 

def get_area_of_all_covered_points(tracks): 
    all_points = [] 
    for track in tracks: 
        for state in track["states"]: 
            if "centerX" in state and "centerY" in state: 
                all_points.append(Point(state["centerX"], state["centerY"]))
    trajectory_cloud = MultiPoint(all_points)
    buffered_area = trajectory_cloud.buffer(2.0)
    return buffered_area


def get_polygon_of_all_map_elements(map_data_raw): 
    all_lanes = map_data_raw["lanes"]
    all_crosswalks = map_data_raw["crosswalks"]
    all_polygons = []
    polygons_index = []

    for lane in all_lanes: 
        polygon_pts = []
        for pt in all_lanes[lane]["lane"]["polyline"]: 
            polygon_pts.append((pt["x"], pt["y"]))
        polygon_curr = Polygon(polygon_pts)
        all_polygons.append(polygon_curr)
        polygons_index.append(lane)
    
    for crswlk in all_crosswalks: 
        polygon_pts = []
        for pt in all_crosswalks[crswlk]["crosswalk"]["polygon"]: 
            polygon_pts.append((pt["x"], pt["y"]))
        polygon_curr = Polygon(polygon_pts)
        all_polygons.append(polygon_curr)
        polygons_index.append(crswlk)

    return all_polygons, polygons_index


def get_candidate_map_elements(buffered_area, all_polygons, polygons_index): 
    all_covered_map_elements = []
    tree = STRtree(all_polygons)
    candidate_polygons = tree.query(buffered_area)
    relevant_polygons = [poly for poly in candidate_polygons if poly.intersects(buffered_area)]
    for plgn in relevant_polygons: 
        plgn_index = all_polygons.index(plgn)
        map_element_index = polygons_index[plgn_index]
        all_covered_map_elements.append(map_element_index)
    return all_covered_map_elements


def get_covered_roadlines(lanes_covered, all_roadlines): 
    roadlines_id = set()
    for lane in lanes_covered: 
        for bound in lane["lane"]["leftBoundaries"]: 
            roadlines_id.add(bound["boundaryFeatureId"])
        for bound in lane["lane"]["rightBoundaries"]: 
            roadlines_id.add(bound["boundaryFeatureId"])
    
    roadlines_covered = []
    for rdln_id in roadlines_id: 
        roadlines_covered.append(all_roadlines[rdln_id])
    
    return roadlines_covered

from av2.datasets.motion_forecasting import scenario_serialization
from av2.map.map_api import ArgoverseStaticMap
from pathlib import Path
from shapely.geometry import Point, Polygon


def get_all_track_points(tracks): 
    all_waypoints = []
    for item in tracks: 
        states = item.object_states
        for state in states: 
            waypoint = Point(state.position)
            all_waypoints.append(waypoint)
    return all_waypoints


def get_all_lane_segment_polygons(lane_segments): 
    all_polygons = []
    for segment in lane_segments: 
        boundary = segment.polygon_boundary[:, :2].tolist()
        seg_polygon = Polygon(boundary)
        all_polygons.append((segment.id, seg_polygon))
    return all_polygons


def get_all_lane_segments_covered(tracks, lane_segments): 
    lane_ids = set()
    all_waypoints = get_all_track_points(tracks)
    all_polygons = get_all_lane_segment_polygons(lane_segments)
    for waypoint in all_waypoints: 
        for polygon in all_polygons: 
            if polygon[-1].contains(waypoint): 
                lane_ids.add(polygon[0])
    return lane_ids


def get_all_neighbor_lanes_shared(lane_id_covered, map_data): 
    all_neighbor_lanes = []
    neighbor_lanes_shared = []
    for lane in lane_id_covered: 
        # Left
        neighbor_left = map_data.get_lane_segment_left_neighbor_id(lane)
        if neighbor_left: 
            if neighbor_left not in all_neighbor_lanes:  # Appeared at the first time
                all_neighbor_lanes.append(neighbor_left)
            else:  # Appeared more times
                neighbor_lanes_shared.append(neighbor_left)
        # Right
        neighbor_right = map_data.get_lane_segment_right_neighbor_id(lane)
        if neighbor_right: 
            if neighbor_right not in all_neighbor_lanes: 
                all_neighbor_lanes.append(neighbor_right)
            else:  # Appeared more times
                neighbor_lanes_shared.append(neighbor_right)
    return neighbor_lanes_shared


def get_scenario_city_name(scenario_data): 
    return scenario_data.city_name


def build_scenario_dict_(data_dir, map_dir): 
    scenario_data = scenario_serialization.load_argoverse_scenario_parquet(Path(data_dir))
    map_data = ArgoverseStaticMap.from_map_dir(log_map_dirpath=Path(map_dir), build_raster=False)
    scenario_data_waymo = build_scenario_dict_from_argoverse(scenario_data, map_data)
    return scenario_data_waymo


"""
Functions for parsing Argoverse2 dataset samples
"""


def build_scenario_dict_from_argoverse(scenario_data, map_data): 
    timestamps_seconds = get_timestamps_seconds(scenario_data.timestamps_ns)
    tracks, ego_idx = get_tracks(scenario_data.tracks)
    scenario_dict = {
        "timestampsSeconds": timestamps_seconds, 
        "tracks": tracks, 
        "objectsOfInterest": [],  # Generated by models
        "scenarioId": scenario_data.city_name + scenario_data.scenario_id, 
        "sdcTrackIndex": ego_idx, 
        "dynamicMapStates": [{"laneStates": []} for _ in range(len(timestamps_seconds))],  # Do not support this field
        "mapFeatures": get_map_features(map_data), 
        "currentTimeIndex": 10, 
        "tracksToPredict": [],  # Generated by models
    }

    return scenario_dict


def get_timestamps_seconds(scenario_data_timestamps_ns): 
    timestamps_seconds = []
    t_start = scenario_data_timestamps_ns[0]
    for t in scenario_data_timestamps_ns: 
        t_second = (t - t_start)*(10**-9)
        timestamps_seconds.append(t_second)
    return timestamps_seconds


def object_type_parser(object_type_agvs): 
    obj_type_mapping = {
        "ObjectType.UNKNOWN": "TYPE_UNSET", 
        "ObjectType.VEHICLE": "TYPE_VEHICLE", 
        "ObjectType.PEDESTRIAN": "TYPE_PEDESTRIAN", 
        "ObjectType.MOTORCYCLIST": "TYPE_CYCLIST", 
        "ObjectType.CYCLIST": "TYPE_CYCLIST", 
        "ObjectType.BUS": "TYPE_VEHICLE", 
        "ObjectType.STATIC": "TYPE_OTHER", 
        "ObjectType.BACKGROUND": "TYPE_OTHER", 
        "ObjectType.CONSTRUCTION": "TYPE_OTHER", 
        "ObjectType.RIDERLESS_BICYCLE": "TYPE_OTHER"
    }
    return obj_type_mapping[str(object_type_agvs)]


def object_length_width(object_type_agvs): 
    # ["ObjectType.VEHICLE", "ObjectType.PEDESTRIAN", "ObjectType.MOTORCYCLIST", "ObjectType.CYCLIST", "ObjectType.BUS"]
    obj_size = {
        "ObjectType.VEHICLE": (4.0, 2.0, 2.0), 
        "ObjectType.PEDESTRIAN": (0.7, 0.7, 2.0), 
        "ObjectType.MOTORCYCLIST": (2.0, 0.7, 2.0), 
        "ObjectType.CYCLIST": (2.0, 0.7, 2.0), 
        "ObjectType.BUS": (12.0, 2.5, 4.0)
    }
    return obj_size[str(object_type_agvs)]


def get_dummy_object_state(): 
    dummy_object_state = {
        "valid": False
    }
    return dummy_object_state


def get_states_per_object(object_type, object_states, is_av): 
    states = [get_dummy_object_state() for _ in range(110)]
    for obj_state in object_states: 
        idx = obj_state.timestep
        states[idx]["centerX"] = obj_state.position[0]
        states[idx]["centerY"] = obj_state.position[1]
        states[idx]["centerZ"] = 0.001
        states[idx]["heading"] = obj_state.heading
        states[idx]["velocityX"] = obj_state.velocity[0]
        states[idx]["velocityY"] = obj_state.velocity[1]
        if is_av: 
            states[idx]["valid"] = True
        else: 
            states[idx]["valid"] = obj_state.observed
        if object_type in ["ObjectType.VEHICLE", "ObjectType.PEDESTRIAN", 
                           "ObjectType.MOTORCYCLIST", "ObjectType.CYCLIST", 
                           "ObjectType.BUS"]: 
            size = object_length_width(object_type)
            states[idx]["length"] = size[0]
            states[idx]["width"] = size[1]
            states[idx]["height"] = size[2]
    return states


def get_tracks(scenario_data_tracks): 
    tracks = []
    for obstacle in scenario_data_tracks: 
        is_av = False
        if obstacle.track_id == "AV": 
            obstacle.track_id = "0"
            is_av = True
        object_states = get_states_per_object(str(obstacle.object_type), obstacle.object_states, is_av)
        track = {
            "id": int(obstacle.track_id), 
            # "id": obstacle.track_id, 
            "objectType": object_type_parser(obstacle.object_type), 
            "states": object_states
        }
        tracks.append(track)
    ego_index = -1
    for i in range(len(tracks)): 
        if tracks[i]["id"] == 0: 
            ego_index = i
            break
    return tracks, ego_index


def get_road_seg_type_speed_limit(lane_center): 
    lane_type_mapping = {
        "LaneType.VEHICLE": "TYPE_SURFACE_STREET", 
        "LaneType.BUS": "TYPE_SURFACE_STREET", 
        "LaneType.BIKE": "TYPE_BIKE_LANE"
    }
    speed_limit_mapping = {
        "LaneType.VEHICLE": 40.0, 
        "LaneType.BUS": 40.0, 
        "LaneType.BIKE": 7.0
    }
    return lane_type_mapping[str(lane_center)], speed_limit_mapping[str(lane_center)]


def get_lane_polyline(map_data, lane_id): 
    points = map_data.get_lane_segment_centerline(lane_id).tolist()
    polyline = []
    for pt in points: 
        polyline.append({"x": pt[0], "y": pt[1], "z": pt[2]})
    return polyline


def get_boundary_type(lane_mark_type): 
    lane_mark_mapping = {
        "LaneMarkType.UNKNOWN": "TYPE_UNKNOWN", 
        "LaneMarkType.NONE": "TYPE_UNKNOWN", 
        "LaneMarkType.SOLID_BLUE": "TYPE_UNKNOWN", 
        "LaneMarkType.DASHED_WHITE": "TYPE_BROKEN_SINGLE_WHITE", 
        "LaneMarkType.SOLID_DASH_WHITE": "TYPE_BROKEN_SINGLE_WHITE", 
        "LaneMarkType.SOLID_WHITE": "TYPE_SOLID_SINGLE_WHITE", 
        "LaneMarkType.DASH_SOLID_WHITE": "TYPE_SOLID_SINGLE_WHITE", 
        "LaneMarkType.DOUBLE_SOLID_WHITE": "TYPE_SOLID_DOUBLE_WHITE", 
        "LaneMarkType.DOUBLE_DASH_WHITE": "TYPE_SOLID_DOUBLE_WHITE", 
        "LaneMarkType.DASHED_YELLOW": "TYPE_BROKEN_SINGLE_YELLOW", 
        "LaneMarkType.DOUBLE_DASH_YELLOW": "TYPE_BROKEN_DOUBLE_YELLOW", 
        "LaneMarkType.DASH_SOLID_YELLOW": "TYPE_BROKEN_DOUBLE_YELLOW", 
        "LaneMarkType.SOLID_YELLOW": "TYPE_SOLID_SINGLE_YELLOW", 
        "LaneMarkType.DOUBLE_SOLID_YELLOW": "TYPE_SOLID_DOUBLE_YELLOW", 
        "LaneMarkType.SOLID_DASH_YELLOW": "TYPE_PASSING_DOUBLE_YELLOW", 
    }
    return lane_mark_mapping[str(lane_mark_type)]


def get_boundary_polyline(lane_segment_boundary): 
    polyline = []
    for pt in lane_segment_boundary.waypoints: 
        point = {"x": pt.x, "y": pt.y, "z": pt.z}
        polyline.append(point)
    # for pt in reversed(lane_segment_boundary.waypoints): 
    #     point = {"x": pt.x, "y": pt.y, "z": pt.z}
    #     polyline.append(point)
    return polyline


def get_left_lane_neighbor(map_lane_seg, boundary):
    left_lane_neighbor = {
        "featureId": str(map_lane_seg.left_neighbor_id), 
        "boundaries": boundary
    }
    return left_lane_neighbor


def get_right_lane_neighbor(map_lane_seg, boundary):
    right_lane_neighbor = {
        "featureId": str(map_lane_seg.right_neighbor_id), 
        "boundaries": boundary
    }
    return right_lane_neighbor


def get_lane(map_lane_seg, all_roadlines_dict, map_data): 
    lane = {"id": str(map_lane_seg.id)}
    lane_type, spd_limit = get_road_seg_type_speed_limit(map_lane_seg.lane_type)
    lane_center = {"type": lane_type, "speedLimitMph": spd_limit}
    lane_center["interpolating"] = False
    lane_center["polyline"] = get_lane_polyline(map_data, map_lane_seg.id)
    if map_lane_seg.predecessors: 
        lane_center["entryLanes"] = map_lane_seg.predecessors
    if map_lane_seg.successors: 
        lane_center["exitLanes"] = map_lane_seg.successors
    left_boundary = get_boundary(all_roadlines_dict, map_lane_seg.id, map_lane_seg.left_neighbor_id)
    if left_boundary: 
        lane_center["leftBoundaries"] = left_boundary
        left_neighbor = get_left_lane_neighbor(map_lane_seg, left_boundary)
        lane_center["leftNeighbors"] = [left_neighbor]
    right_boundary = get_boundary(all_roadlines_dict, map_lane_seg.id, map_lane_seg.right_neighbor_id)
    if right_boundary: 
        lane_center["rightBoundaries"] = right_boundary
        right_neighbor = get_right_lane_neighbor(map_lane_seg, right_boundary)
        lane_center["rightNeighbors"] = [right_neighbor]
    lane["lane"] = lane_center
    return lane


def get_lanes(all_lane_ids, map_data):
    map_lane_segments = map_data.get_scenario_lane_segments()
    all_roadlines_dict = get_roadlines_dict(all_lane_ids, map_lane_segments)
    all_lanes = []
    for seg in map_lane_segments: 
        lane = get_lane(seg, all_roadlines_dict, map_data)
        all_lanes.append(lane)
    return all_lanes


def get_roadline_id(id_roadline_mark, all_lane_ids): 
    while(id_roadline_mark in all_lane_ids): 
        id_roadline_mark += 1
    road_line_id = str(id_roadline_mark)
    id_roadline_mark += 1
    return road_line_id, id_roadline_mark


def get_roadlines_dict(all_lane_ids, map_lane_segments): 
    all_roadlines = {}
    id_roadline_mark = 1
    for seg in map_lane_segments: 
        if seg.left_neighbor_id: 
            if f"{seg.id}-{seg.left_neighbor_id}" not in all_roadlines \
                and f"{seg.left_neighbor_id}-{seg.id}" not in all_roadlines: 
                road_line_id, id_roadline_mark = get_roadline_id(id_roadline_mark, all_lane_ids)
                road_line = {
                    "type": get_boundary_type(seg.left_mark_type), 
                    "polyline": get_boundary_polyline(seg.left_lane_boundary)
                }
                road_line_curr = {
                    "id": str(road_line_id), 
                    "roadLine": road_line
                }
                all_roadlines[f"{seg.id}-{seg.left_neighbor_id}"] = road_line_curr
        if seg.right_neighbor_id: 
            if f"{seg.id}-{seg.right_neighbor_id}" not in all_roadlines \
                and f"{seg.right_neighbor_id}-{seg.id}" not in all_roadlines: 
                road_line_id, id_roadline_mark = get_roadline_id(id_roadline_mark, all_lane_ids)
                road_line = {
                    "type": get_boundary_type(seg.right_mark_type), 
                    "polyline": get_boundary_polyline(seg.right_lane_boundary)
                }
                road_line_curr = {
                    "id": str(road_line_id), 
                    "roadLine": road_line
                }
                all_roadlines[f"{seg.id}-{seg.right_neighbor_id}"] = road_line_curr
    return all_roadlines


def get_boundary(all_roadlines_dict, lane_id, lane_neighbor_id):
    roadline_key = ""
    if f"{lane_id}-{lane_neighbor_id}" in all_roadlines_dict: 
        roadline_key = f"{lane_id}-{lane_neighbor_id}"
    elif f"{lane_neighbor_id}-{lane_id}" in all_roadlines_dict: 
        roadline_key = f"{lane_neighbor_id}-{lane_id}"
    else: 
        return None
    roadline = {
        "boundaryFeatureId": all_roadlines_dict[roadline_key]["id"], 
        "boundaryType": all_roadlines_dict[roadline_key]["roadLine"]["type"]
    }
    return [roadline]


def get_roadlines(all_roadlines_dict): 
    return list(all_roadlines_dict.values())


def get_crosswalks(map_pedestrian_crossings): 
    crosswalks = []
    for crswlk in map_pedestrian_crossings: 
        crosswalk = {"id": str(crswlk.id)}
        polygon_pts = []
        for pt in crswlk.edge1.waypoints: 
            point = {"x":pt.x, "y": pt.y, "z": pt.z}
            polygon_pts.append(point)
        for pt in crswlk.edge2.waypoints: 
            point = {"x":pt.x, "y": pt.y, "z": pt.z}
            polygon_pts.append(point)
        crosswalk["crosswalk"] = {"polygon": polygon_pts}
        crosswalks.append(crosswalk)
    return crosswalks


def get_map_features(map_data): 
    all_lanes_id = map_data.get_scenario_lane_segment_ids()
    lane_segments = map_data.get_scenario_lane_segments()
    ped_crossings = map_data.get_scenario_ped_crossings()
    all_roadlines_dict = get_roadlines_dict(all_lanes_id, lane_segments)
    all_lanes = get_lanes(all_lanes_id, map_data)
    all_crosswalks = get_crosswalks(ped_crossings)
    all_roadlines = get_roadlines(all_roadlines_dict)
    map_features = all_roadlines + all_lanes + all_crosswalks
    return map_features